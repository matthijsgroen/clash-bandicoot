/*! For license information please see service-worker.js.LICENSE.txt */
!function(){"use strict";var __webpack_modules__={"./node_modules/workbox-core/_version.js":function(){try{self["workbox:core:6.6.0"]&&_()}catch(e){}},"./node_modules/workbox-expiration/_version.js":function(){try{self["workbox:expiration:6.6.0"]&&_()}catch(e){}},"./node_modules/workbox-precaching/_version.js":function(){try{self["workbox:precaching:6.6.0"]&&_()}catch(e){}},"./node_modules/workbox-routing/_version.js":function(){try{self["workbox:routing:6.6.0"]&&_()}catch(e){}},"./node_modules/workbox-strategies/_version.js":function(){try{self["workbox:strategies:6.6.0"]&&_()}catch(e){}}},__webpack_module_cache__={};function __webpack_require__(moduleId){var cachedModule=__webpack_module_cache__[moduleId];if(void 0!==cachedModule)return cachedModule.exports;var module=__webpack_module_cache__[moduleId]={exports:{}};return __webpack_modules__[moduleId](module,module.exports,__webpack_require__),module.exports}!function(){function _typeof(obj){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&"function"==typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj},_typeof(obj)}function _regeneratorRuntime(){_regeneratorRuntime=function _regeneratorRuntime(){return exports};var exports={},Op=Object.prototype,hasOwn=Op.hasOwnProperty,defineProperty=Object.defineProperty||function(obj,key,desc){obj[key]=desc.value},$Symbol="function"==typeof Symbol?Symbol:{},iteratorSymbol=$Symbol.iterator||"@@iterator",asyncIteratorSymbol=$Symbol.asyncIterator||"@@asyncIterator",toStringTagSymbol=$Symbol.toStringTag||"@@toStringTag";function define(obj,key,value){return Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}),obj[key]}try{define({},"")}catch(err){define=function define(obj,key,value){return obj[key]=value}}function wrap(innerFn,outerFn,self,tryLocsList){var protoGenerator=outerFn&&outerFn.prototype instanceof Generator?outerFn:Generator,generator=Object.create(protoGenerator.prototype),context=new Context(tryLocsList||[]);return defineProperty(generator,"_invoke",{value:makeInvokeMethod(innerFn,self,context)}),generator}function tryCatch(fn,obj,arg){try{return{type:"normal",arg:fn.call(obj,arg)}}catch(err){return{type:"throw",arg:err}}}exports.wrap=wrap;var ContinueSentinel={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var IteratorPrototype={};define(IteratorPrototype,iteratorSymbol,(function(){return this}));var getProto=Object.getPrototypeOf,NativeIteratorPrototype=getProto&&getProto(getProto(values([])));NativeIteratorPrototype&&NativeIteratorPrototype!==Op&&hasOwn.call(NativeIteratorPrototype,iteratorSymbol)&&(IteratorPrototype=NativeIteratorPrototype);var Gp=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(IteratorPrototype);function defineIteratorMethods(prototype){["next","throw","return"].forEach((function(method){define(prototype,method,(function(arg){return this._invoke(method,arg)}))}))}function AsyncIterator(generator,PromiseImpl){function invoke(method,arg,resolve,reject){var record=tryCatch(generator[method],generator,arg);if("throw"!==record.type){var result=record.arg,value=result.value;return value&&"object"==_typeof(value)&&hasOwn.call(value,"__await")?PromiseImpl.resolve(value.__await).then((function(value){invoke("next",value,resolve,reject)}),(function(err){invoke("throw",err,resolve,reject)})):PromiseImpl.resolve(value).then((function(unwrapped){result.value=unwrapped,resolve(result)}),(function(error){return invoke("throw",error,resolve,reject)}))}reject(record.arg)}var previousPromise;defineProperty(this,"_invoke",{value:function value(method,arg){function callInvokeWithMethodAndArg(){return new PromiseImpl((function(resolve,reject){invoke(method,arg,resolve,reject)}))}return previousPromise=previousPromise?previousPromise.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(innerFn,self,context){var state="suspendedStart";return function(method,arg){if("executing"===state)throw new Error("Generator is already running");if("completed"===state){if("throw"===method)throw arg;return doneResult()}for(context.method=method,context.arg=arg;;){var delegate=context.delegate;if(delegate){var delegateResult=maybeInvokeDelegate(delegate,context);if(delegateResult){if(delegateResult===ContinueSentinel)continue;return delegateResult}}if("next"===context.method)context.sent=context._sent=context.arg;else if("throw"===context.method){if("suspendedStart"===state)throw state="completed",context.arg;context.dispatchException(context.arg)}else"return"===context.method&&context.abrupt("return",context.arg);state="executing";var record=tryCatch(innerFn,self,context);if("normal"===record.type){if(state=context.done?"completed":"suspendedYield",record.arg===ContinueSentinel)continue;return{value:record.arg,done:context.done}}"throw"===record.type&&(state="completed",context.method="throw",context.arg=record.arg)}}}function maybeInvokeDelegate(delegate,context){var methodName=context.method,method=delegate.iterator[methodName];if(void 0===method)return context.delegate=null,"throw"===methodName&&delegate.iterator.return&&(context.method="return",context.arg=void 0,maybeInvokeDelegate(delegate,context),"throw"===context.method)||"return"!==methodName&&(context.method="throw",context.arg=new TypeError("The iterator does not provide a '"+methodName+"' method")),ContinueSentinel;var record=tryCatch(method,delegate.iterator,context.arg);if("throw"===record.type)return context.method="throw",context.arg=record.arg,context.delegate=null,ContinueSentinel;var info=record.arg;return info?info.done?(context[delegate.resultName]=info.value,context.next=delegate.nextLoc,"return"!==context.method&&(context.method="next",context.arg=void 0),context.delegate=null,ContinueSentinel):info:(context.method="throw",context.arg=new TypeError("iterator result is not an object"),context.delegate=null,ContinueSentinel)}function pushTryEntry(locs){var entry={tryLoc:locs[0]};1 in locs&&(entry.catchLoc=locs[1]),2 in locs&&(entry.finallyLoc=locs[2],entry.afterLoc=locs[3]),this.tryEntries.push(entry)}function resetTryEntry(entry){var record=entry.completion||{};record.type="normal",delete record.arg,entry.completion=record}function Context(tryLocsList){this.tryEntries=[{tryLoc:"root"}],tryLocsList.forEach(pushTryEntry,this),this.reset(!0)}function values(iterable){if(iterable){var iteratorMethod=iterable[iteratorSymbol];if(iteratorMethod)return iteratorMethod.call(iterable);if("function"==typeof iterable.next)return iterable;if(!isNaN(iterable.length)){var i=-1,next=function next(){for(;++i<iterable.length;)if(hasOwn.call(iterable,i))return next.value=iterable[i],next.done=!1,next;return next.value=void 0,next.done=!0,next};return next.next=next}}return{next:doneResult}}function doneResult(){return{value:void 0,done:!0}}return GeneratorFunction.prototype=GeneratorFunctionPrototype,defineProperty(Gp,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),defineProperty(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,toStringTagSymbol,"GeneratorFunction"),exports.isGeneratorFunction=function(genFun){var ctor="function"==typeof genFun&&genFun.constructor;return!!ctor&&(ctor===GeneratorFunction||"GeneratorFunction"===(ctor.displayName||ctor.name))},exports.mark=function(genFun){return Object.setPrototypeOf?Object.setPrototypeOf(genFun,GeneratorFunctionPrototype):(genFun.__proto__=GeneratorFunctionPrototype,define(genFun,toStringTagSymbol,"GeneratorFunction")),genFun.prototype=Object.create(Gp),genFun},exports.awrap=function(arg){return{__await:arg}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,asyncIteratorSymbol,(function(){return this})),exports.AsyncIterator=AsyncIterator,exports.async=function(innerFn,outerFn,self,tryLocsList,PromiseImpl){void 0===PromiseImpl&&(PromiseImpl=Promise);var iter=new AsyncIterator(wrap(innerFn,outerFn,self,tryLocsList),PromiseImpl);return exports.isGeneratorFunction(outerFn)?iter:iter.next().then((function(result){return result.done?result.value:iter.next()}))},defineIteratorMethods(Gp),define(Gp,toStringTagSymbol,"Generator"),define(Gp,iteratorSymbol,(function(){return this})),define(Gp,"toString",(function(){return"[object Generator]"})),exports.keys=function(val){var object=Object(val),keys=[];for(var key in object)keys.push(key);return keys.reverse(),function next(){for(;keys.length;){var key=keys.pop();if(key in object)return next.value=key,next.done=!1,next}return next.done=!0,next}},exports.values=values,Context.prototype={constructor:Context,reset:function reset(skipTempReset){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(resetTryEntry),!skipTempReset)for(var name in this)"t"===name.charAt(0)&&hasOwn.call(this,name)&&!isNaN(+name.slice(1))&&(this[name]=void 0)},stop:function stop(){this.done=!0;var rootRecord=this.tryEntries[0].completion;if("throw"===rootRecord.type)throw rootRecord.arg;return this.rval},dispatchException:function dispatchException(exception){if(this.done)throw exception;var context=this;function handle(loc,caught){return record.type="throw",record.arg=exception,context.next=loc,caught&&(context.method="next",context.arg=void 0),!!caught}for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i],record=entry.completion;if("root"===entry.tryLoc)return handle("end");if(entry.tryLoc<=this.prev){var hasCatch=hasOwn.call(entry,"catchLoc"),hasFinally=hasOwn.call(entry,"finallyLoc");if(hasCatch&&hasFinally){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0);if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}else if(hasCatch){if(this.prev<entry.catchLoc)return handle(entry.catchLoc,!0)}else{if(!hasFinally)throw new Error("try statement without catch or finally");if(this.prev<entry.finallyLoc)return handle(entry.finallyLoc)}}}},abrupt:function abrupt(type,arg){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc<=this.prev&&hasOwn.call(entry,"finallyLoc")&&this.prev<entry.finallyLoc){var finallyEntry=entry;break}}finallyEntry&&("break"===type||"continue"===type)&&finallyEntry.tryLoc<=arg&&arg<=finallyEntry.finallyLoc&&(finallyEntry=null);var record=finallyEntry?finallyEntry.completion:{};return record.type=type,record.arg=arg,finallyEntry?(this.method="next",this.next=finallyEntry.finallyLoc,ContinueSentinel):this.complete(record)},complete:function complete(record,afterLoc){if("throw"===record.type)throw record.arg;return"break"===record.type||"continue"===record.type?this.next=record.arg:"return"===record.type?(this.rval=this.arg=record.arg,this.method="return",this.next="end"):"normal"===record.type&&afterLoc&&(this.next=afterLoc),ContinueSentinel},finish:function finish(finallyLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.finallyLoc===finallyLoc)return this.complete(entry.completion,entry.afterLoc),resetTryEntry(entry),ContinueSentinel}},catch:function _catch(tryLoc){for(var i=this.tryEntries.length-1;i>=0;--i){var entry=this.tryEntries[i];if(entry.tryLoc===tryLoc){var record=entry.completion;if("throw"===record.type){var thrown=record.arg;resetTryEntry(entry)}return thrown}}throw new Error("illegal catch attempt")},delegateYield:function delegateYield(iterable,resultName,nextLoc){return this.delegate={iterator:values(iterable),resultName:resultName,nextLoc:nextLoc},"next"===this.method&&(this.arg=void 0),ContinueSentinel}},exports}function _toPropertyKey(arg){var key=function _toPrimitive(input,hint){if("object"!==_typeof(input)||null===input)return input;var prim=input[Symbol.toPrimitive];if(void 0!==prim){var res=prim.call(input,hint||"default");if("object"!==_typeof(res))return res;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===hint?String:Number)(input)}(arg,"string");return"symbol"===_typeof(key)?key:String(key)}function _defineProperty(obj,key,value){return(key=_toPropertyKey(key))in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value,obj}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter((function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable}))),keys.push.apply(keys,symbols)}return keys}function _objectSpread2(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach((function(key){_defineProperty(target,key,source[key])})):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach((function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))}))}return target}function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg),value=info.value}catch(error){return void reject(error)}info.done?resolve(value):Promise.resolve(value).then(_next,_throw)}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise((function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(void 0)}))}}__webpack_require__("./node_modules/workbox-core/_version.js");const messageGenerator=(code,...args)=>{let msg=code;return args.length>0&&(msg+=` :: ${JSON.stringify(args)}`),msg};class WorkboxError_WorkboxError extends Error{constructor(errorCode,details){super(messageGenerator(errorCode,details)),this.name=errorCode,this.details=details}}const quotaErrorCallbacks=new Set;const _cacheNameDetails={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:"undefined"!=typeof registration?registration.scope:""},_createCacheName=cacheName=>[_cacheNameDetails.prefix,cacheName,_cacheNameDetails.suffix].filter((value=>value&&value.length>0)).join("-"),cacheNames_cacheNames_getPrecacheName=userCacheName=>userCacheName||_createCacheName(_cacheNameDetails.precache),cacheNames_cacheNames_getRuntimeName=userCacheName=>userCacheName||_createCacheName(_cacheNameDetails.runtime);function stripParams(fullURL,ignoreParams){const strippedURL=new URL(fullURL);for(const param of ignoreParams)strippedURL.searchParams.delete(param);return strippedURL.href}let canConstructResponseFromBodyStream_supportStatus;function dontWaitFor(promise){promise.then((()=>{}))}class Deferred{constructor(){this.promise=new Promise(((resolve,reject)=>{this.resolve=resolve,this.reject=reject}))}}const getFriendlyURL=url=>new URL(String(url),location.href).href.replace(new RegExp(`^${location.origin}`),"");function timeout_timeout(ms){return new Promise((resolve=>setTimeout(resolve,ms)))}function waitUntil(event,asyncFn){const returnPromise=asyncFn();return event.waitUntil(returnPromise),returnPromise}async function copyResponse(response,modifier){let origin=null;if(response.url){origin=new URL(response.url).origin}if(origin!==self.location.origin)throw new WorkboxError_WorkboxError("cross-origin-copy-response",{origin:origin});const clonedResponse=response.clone(),responseInit={headers:new Headers(clonedResponse.headers),status:clonedResponse.status,statusText:clonedResponse.statusText},modifiedResponseInit=modifier?modifier(responseInit):responseInit,body=function canConstructResponseFromBodyStream(){if(void 0===canConstructResponseFromBodyStream_supportStatus){const testResponse=new Response("");if("body"in testResponse)try{new Response(testResponse.body),canConstructResponseFromBodyStream_supportStatus=!0}catch(error){canConstructResponseFromBodyStream_supportStatus=!1}canConstructResponseFromBodyStream_supportStatus=!1}return canConstructResponseFromBodyStream_supportStatus}()?clonedResponse.body:await clonedResponse.blob();return new Response(body,modifiedResponseInit)}const instanceOfAny=(object,constructors)=>constructors.some((c=>object instanceof c));let idbProxyableTypes,cursorAdvanceMethods;const cursorRequestMap=new WeakMap,transactionDoneMap=new WeakMap,transactionStoreNamesMap=new WeakMap,transformCache=new WeakMap,reverseTransformCache=new WeakMap;let idbProxyTraps={get(target,prop,receiver){if(target instanceof IDBTransaction){if("done"===prop)return transactionDoneMap.get(target);if("objectStoreNames"===prop)return target.objectStoreNames||transactionStoreNamesMap.get(target);if("store"===prop)return receiver.objectStoreNames[1]?void 0:receiver.objectStore(receiver.objectStoreNames[0])}return wrap(target[prop])},set(target,prop,value){return target[prop]=value,!0},has(target,prop){return target instanceof IDBTransaction&&("done"===prop||"store"===prop)||prop in target}};function wrapFunction(func){return func!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?function getCursorAdvanceMethods(){return cursorAdvanceMethods||(cursorAdvanceMethods=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])}().includes(func)?function(...args){return func.apply(unwrap(this),args),wrap(cursorRequestMap.get(this))}:function(...args){return wrap(func.apply(unwrap(this),args))}:function(storeNames,...args){const tx=func.call(unwrap(this),storeNames,...args);return transactionStoreNamesMap.set(tx,storeNames.sort?storeNames.sort():[storeNames]),wrap(tx)}}function transformCachableValue(value){return"function"==typeof value?wrapFunction(value):(value instanceof IDBTransaction&&function cacheDonePromiseForTransaction(tx){if(transactionDoneMap.has(tx))return;const done=new Promise(((resolve,reject)=>{const unlisten=()=>{tx.removeEventListener("complete",complete),tx.removeEventListener("error",error),tx.removeEventListener("abort",error)},complete=()=>{resolve(),unlisten()},error=()=>{reject(tx.error||new DOMException("AbortError","AbortError")),unlisten()};tx.addEventListener("complete",complete),tx.addEventListener("error",error),tx.addEventListener("abort",error)}));transactionDoneMap.set(tx,done)}(value),instanceOfAny(value,function getIdbProxyableTypes(){return idbProxyableTypes||(idbProxyableTypes=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction])}())?new Proxy(value,idbProxyTraps):value)}function wrap(value){if(value instanceof IDBRequest)return function promisifyRequest(request){const promise=new Promise(((resolve,reject)=>{const unlisten=()=>{request.removeEventListener("success",success),request.removeEventListener("error",error)},success=()=>{resolve(wrap(request.result)),unlisten()},error=()=>{reject(request.error),unlisten()};request.addEventListener("success",success),request.addEventListener("error",error)}));return promise.then((value=>{value instanceof IDBCursor&&cursorRequestMap.set(value,request)})).catch((()=>{})),reverseTransformCache.set(promise,request),promise}(value);if(transformCache.has(value))return transformCache.get(value);const newValue=transformCachableValue(value);return newValue!==value&&(transformCache.set(value,newValue),reverseTransformCache.set(newValue,value)),newValue}const unwrap=value=>reverseTransformCache.get(value);const readMethods=["get","getKey","getAll","getAllKeys","count"],writeMethods=["put","add","delete","clear"],cachedMethods=new Map;function getMethod(target,prop){if(!(target instanceof IDBDatabase)||prop in target||"string"!=typeof prop)return;if(cachedMethods.get(prop))return cachedMethods.get(prop);const targetFuncName=prop.replace(/FromIndex$/,""),useIndex=prop!==targetFuncName,isWrite=writeMethods.includes(targetFuncName);if(!(targetFuncName in(useIndex?IDBIndex:IDBObjectStore).prototype)||!isWrite&&!readMethods.includes(targetFuncName))return;const method=async function(storeName,...args){const tx=this.transaction(storeName,isWrite?"readwrite":"readonly");let target=tx.store;return useIndex&&(target=target.index(args.shift())),(await Promise.all([target[targetFuncName](...args),isWrite&&tx.done]))[0]};return cachedMethods.set(prop,method),method}!function replaceTraps(callback){idbProxyTraps=callback(idbProxyTraps)}((oldTraps=>({...oldTraps,get:(target,prop,receiver)=>getMethod(target,prop)||oldTraps.get(target,prop,receiver),has:(target,prop)=>!!getMethod(target,prop)||oldTraps.has(target,prop)})));__webpack_require__("./node_modules/workbox-expiration/_version.js");const normalizeURL=unNormalizedUrl=>{const url=new URL(unNormalizedUrl,location.href);return url.hash="",url.href};class CacheTimestampsModel{constructor(cacheName){this._db=null,this._cacheName=cacheName}_upgradeDb(db){const objStore=db.createObjectStore("cache-entries",{keyPath:"id"});objStore.createIndex("cacheName","cacheName",{unique:!1}),objStore.createIndex("timestamp","timestamp",{unique:!1})}_upgradeDbAndDeleteOldDbs(db){this._upgradeDb(db),this._cacheName&&function deleteDB(name,{blocked:blocked}={}){const request=indexedDB.deleteDatabase(name);return blocked&&request.addEventListener("blocked",(event=>blocked(event.oldVersion,event))),wrap(request).then((()=>{}))}(this._cacheName)}async setTimestamp(url,timestamp){const entry={url:url=normalizeURL(url),timestamp:timestamp,cacheName:this._cacheName,id:this._getId(url)},tx=(await this.getDb()).transaction("cache-entries","readwrite",{durability:"relaxed"});await tx.store.put(entry),await tx.done}async getTimestamp(url){const db=await this.getDb(),entry=await db.get("cache-entries",this._getId(url));return null==entry?void 0:entry.timestamp}async expireEntries(minTimestamp,maxCount){const db=await this.getDb();let cursor=await db.transaction("cache-entries").store.index("timestamp").openCursor(null,"prev");const entriesToDelete=[];let entriesNotDeletedCount=0;for(;cursor;){const result=cursor.value;result.cacheName===this._cacheName&&(minTimestamp&&result.timestamp<minTimestamp||maxCount&&entriesNotDeletedCount>=maxCount?entriesToDelete.push(cursor.value):entriesNotDeletedCount++),cursor=await cursor.continue()}const urlsDeleted=[];for(const entry of entriesToDelete)await db.delete("cache-entries",entry.id),urlsDeleted.push(entry.url);return urlsDeleted}_getId(url){return this._cacheName+"|"+normalizeURL(url)}async getDb(){return this._db||(this._db=await function openDB(name,version,{blocked:blocked,upgrade:upgrade,blocking:blocking,terminated:terminated}={}){const request=indexedDB.open(name,version),openPromise=wrap(request);return upgrade&&request.addEventListener("upgradeneeded",(event=>{upgrade(wrap(request.result),event.oldVersion,event.newVersion,wrap(request.transaction),event)})),blocked&&request.addEventListener("blocked",(event=>blocked(event.oldVersion,event.newVersion,event))),openPromise.then((db=>{terminated&&db.addEventListener("close",(()=>terminated())),blocking&&db.addEventListener("versionchange",(event=>blocking(event.oldVersion,event.newVersion,event)))})).catch((()=>{})),openPromise}("workbox-expiration",1,{upgrade:this._upgradeDbAndDeleteOldDbs.bind(this)})),this._db}}class CacheExpiration{constructor(cacheName,config={}){this._isRunning=!1,this._rerunRequested=!1,this._maxEntries=config.maxEntries,this._maxAgeSeconds=config.maxAgeSeconds,this._matchOptions=config.matchOptions,this._cacheName=cacheName,this._timestampModel=new CacheTimestampsModel(cacheName)}async expireEntries(){if(this._isRunning)return void(this._rerunRequested=!0);this._isRunning=!0;const minTimestamp=this._maxAgeSeconds?Date.now()-1e3*this._maxAgeSeconds:0,urlsExpired=await this._timestampModel.expireEntries(minTimestamp,this._maxEntries),cache=await self.caches.open(this._cacheName);for(const url of urlsExpired)await cache.delete(url,this._matchOptions);this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,dontWaitFor(this.expireEntries()))}async updateTimestamp(url){await this._timestampModel.setTimestamp(url,Date.now())}async isURLExpired(url){if(this._maxAgeSeconds){const timestamp=await this._timestampModel.getTimestamp(url),expireOlderThan=Date.now()-1e3*this._maxAgeSeconds;return void 0===timestamp||timestamp<expireOlderThan}return!1}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}}__webpack_require__("./node_modules/workbox-precaching/_version.js");function createCacheKey(entry){if(!entry)throw new WorkboxError_WorkboxError("add-to-cache-list-unexpected-type",{entry:entry});if("string"==typeof entry){const urlObject=new URL(entry,location.href);return{cacheKey:urlObject.href,url:urlObject.href}}const{revision:revision,url:url}=entry;if(!url)throw new WorkboxError_WorkboxError("add-to-cache-list-unexpected-type",{entry:entry});if(!revision){const urlObject=new URL(url,location.href);return{cacheKey:urlObject.href,url:urlObject.href}}const cacheKeyURL=new URL(url,location.href),originalURL=new URL(url,location.href);return cacheKeyURL.searchParams.set("__WB_REVISION__",revision),{cacheKey:cacheKeyURL.href,url:originalURL.href}}class PrecacheInstallReportPlugin{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:request,state:state})=>{state&&(state.originalRequest=request)},this.cachedResponseWillBeUsed=async({event:event,state:state,cachedResponse:cachedResponse})=>{if("install"===event.type&&state&&state.originalRequest&&state.originalRequest instanceof Request){const url=state.originalRequest.url;cachedResponse?this.notUpdatedURLs.push(url):this.updatedURLs.push(url)}return cachedResponse}}}class PrecacheCacheKeyPlugin{constructor({precacheController:precacheController}){this.cacheKeyWillBeUsed=async({request:request,params:params})=>{const cacheKey=(null==params?void 0:params.cacheKey)||this._precacheController.getCacheKeyForURL(request.url);return cacheKey?new Request(cacheKey,{headers:request.headers}):request},this._precacheController=precacheController}}__webpack_require__("./node_modules/workbox-strategies/_version.js");function toRequest(input){return"string"==typeof input?new Request(input):input}class StrategyHandler{constructor(strategy,options){this._cacheKeys={},Object.assign(this,options),this.event=options.event,this._strategy=strategy,this._handlerDeferred=new Deferred,this._extendLifetimePromises=[],this._plugins=[...strategy.plugins],this._pluginStateMap=new Map;for(const plugin of this._plugins)this._pluginStateMap.set(plugin,{});this.event.waitUntil(this._handlerDeferred.promise)}async fetch(input){const{event:event}=this;let request=toRequest(input);if("navigate"===request.mode&&event instanceof FetchEvent&&event.preloadResponse){const possiblePreloadResponse=await event.preloadResponse;if(possiblePreloadResponse)return possiblePreloadResponse}const originalRequest=this.hasCallback("fetchDidFail")?request.clone():null;try{for(const cb of this.iterateCallbacks("requestWillFetch"))request=await cb({request:request.clone(),event:event})}catch(err){if(err instanceof Error)throw new WorkboxError_WorkboxError("plugin-error-request-will-fetch",{thrownErrorMessage:err.message})}const pluginFilteredRequest=request.clone();try{let fetchResponse;fetchResponse=await fetch(request,"navigate"===request.mode?void 0:this._strategy.fetchOptions);for(const callback of this.iterateCallbacks("fetchDidSucceed"))fetchResponse=await callback({event:event,request:pluginFilteredRequest,response:fetchResponse});return fetchResponse}catch(error){throw originalRequest&&await this.runCallbacks("fetchDidFail",{error:error,event:event,originalRequest:originalRequest.clone(),request:pluginFilteredRequest.clone()}),error}}async fetchAndCachePut(input){const response=await this.fetch(input),responseClone=response.clone();return this.waitUntil(this.cachePut(input,responseClone)),response}async cacheMatch(key){const request=toRequest(key);let cachedResponse;const{cacheName:cacheName,matchOptions:matchOptions}=this._strategy,effectiveRequest=await this.getCacheKey(request,"read"),multiMatchOptions=Object.assign(Object.assign({},matchOptions),{cacheName:cacheName});cachedResponse=await caches.match(effectiveRequest,multiMatchOptions);for(const callback of this.iterateCallbacks("cachedResponseWillBeUsed"))cachedResponse=await callback({cacheName:cacheName,matchOptions:matchOptions,cachedResponse:cachedResponse,request:effectiveRequest,event:this.event})||void 0;return cachedResponse}async cachePut(key,response){const request=toRequest(key);await timeout_timeout(0);const effectiveRequest=await this.getCacheKey(request,"write");if(!response)throw new WorkboxError_WorkboxError("cache-put-with-no-response",{url:getFriendlyURL(effectiveRequest.url)});const responseToCache=await this._ensureResponseSafeToCache(response);if(!responseToCache)return!1;const{cacheName:cacheName,matchOptions:matchOptions}=this._strategy,cache=await self.caches.open(cacheName),hasCacheUpdateCallback=this.hasCallback("cacheDidUpdate"),oldResponse=hasCacheUpdateCallback?await async function cacheMatchIgnoreParams(cache,request,ignoreParams,matchOptions){const strippedRequestURL=stripParams(request.url,ignoreParams);if(request.url===strippedRequestURL)return cache.match(request,matchOptions);const keysOptions=Object.assign(Object.assign({},matchOptions),{ignoreSearch:!0}),cacheKeys=await cache.keys(request,keysOptions);for(const cacheKey of cacheKeys)if(strippedRequestURL===stripParams(cacheKey.url,ignoreParams))return cache.match(cacheKey,matchOptions)}(cache,effectiveRequest.clone(),["__WB_REVISION__"],matchOptions):null;try{await cache.put(effectiveRequest,hasCacheUpdateCallback?responseToCache.clone():responseToCache)}catch(error){if(error instanceof Error)throw"QuotaExceededError"===error.name&&await async function executeQuotaErrorCallbacks(){for(const callback of quotaErrorCallbacks)await callback()}(),error}for(const callback of this.iterateCallbacks("cacheDidUpdate"))await callback({cacheName:cacheName,oldResponse:oldResponse,newResponse:responseToCache.clone(),request:effectiveRequest,event:this.event});return!0}async getCacheKey(request,mode){const key=`${request.url} | ${mode}`;if(!this._cacheKeys[key]){let effectiveRequest=request;for(const callback of this.iterateCallbacks("cacheKeyWillBeUsed"))effectiveRequest=toRequest(await callback({mode:mode,request:effectiveRequest,event:this.event,params:this.params}));this._cacheKeys[key]=effectiveRequest}return this._cacheKeys[key]}hasCallback(name){for(const plugin of this._strategy.plugins)if(name in plugin)return!0;return!1}async runCallbacks(name,param){for(const callback of this.iterateCallbacks(name))await callback(param)}*iterateCallbacks(name){for(const plugin of this._strategy.plugins)if("function"==typeof plugin[name]){const state=this._pluginStateMap.get(plugin),statefulCallback=param=>{const statefulParam=Object.assign(Object.assign({},param),{state:state});return plugin[name](statefulParam)};yield statefulCallback}}waitUntil(promise){return this._extendLifetimePromises.push(promise),promise}async doneWaiting(){let promise;for(;promise=this._extendLifetimePromises.shift();)await promise}destroy(){this._handlerDeferred.resolve(null)}async _ensureResponseSafeToCache(response){let responseToCache=response,pluginsUsed=!1;for(const callback of this.iterateCallbacks("cacheWillUpdate"))if(responseToCache=await callback({request:this.request,response:responseToCache,event:this.event})||void 0,pluginsUsed=!0,!responseToCache)break;return pluginsUsed||responseToCache&&200!==responseToCache.status&&(responseToCache=void 0),responseToCache}}class Strategy_Strategy{constructor(options={}){this.cacheName=cacheNames_cacheNames_getRuntimeName(options.cacheName),this.plugins=options.plugins||[],this.fetchOptions=options.fetchOptions,this.matchOptions=options.matchOptions}handle(options){const[responseDone]=this.handleAll(options);return responseDone}handleAll(options){options instanceof FetchEvent&&(options={event:options,request:options.request});const event=options.event,request="string"==typeof options.request?new Request(options.request):options.request,params="params"in options?options.params:void 0,handler=new StrategyHandler(this,{event:event,request:request,params:params}),responseDone=this._getResponse(handler,request,event);return[responseDone,this._awaitComplete(responseDone,handler,request,event)]}async _getResponse(handler,request,event){let response;await handler.runCallbacks("handlerWillStart",{event:event,request:request});try{if(response=await this._handle(request,handler),!response||"error"===response.type)throw new WorkboxError_WorkboxError("no-response",{url:request.url})}catch(error){if(error instanceof Error)for(const callback of handler.iterateCallbacks("handlerDidError"))if(response=await callback({error:error,event:event,request:request}),response)break;if(!response)throw error}for(const callback of handler.iterateCallbacks("handlerWillRespond"))response=await callback({event:event,request:request,response:response});return response}async _awaitComplete(responseDone,handler,request,event){let response,error;try{response=await responseDone}catch(error){}try{await handler.runCallbacks("handlerDidRespond",{event:event,request:request,response:response}),await handler.doneWaiting()}catch(waitUntilError){waitUntilError instanceof Error&&(error=waitUntilError)}if(await handler.runCallbacks("handlerDidComplete",{event:event,request:request,response:response,error:error}),handler.destroy(),error)throw error}}class PrecacheStrategy extends Strategy_Strategy{constructor(options={}){options.cacheName=cacheNames_cacheNames_getPrecacheName(options.cacheName),super(options),this._fallbackToNetwork=!1!==options.fallbackToNetwork,this.plugins.push(PrecacheStrategy.copyRedirectedCacheableResponsesPlugin)}async _handle(request,handler){const response=await handler.cacheMatch(request);return response||(handler.event&&"install"===handler.event.type?await this._handleInstall(request,handler):await this._handleFetch(request,handler))}async _handleFetch(request,handler){let response;const params=handler.params||{};if(!this._fallbackToNetwork)throw new WorkboxError_WorkboxError("missing-precache-entry",{cacheName:this.cacheName,url:request.url});{0;const integrityInManifest=params.integrity,integrityInRequest=request.integrity,noIntegrityConflict=!integrityInRequest||integrityInRequest===integrityInManifest;if(response=await handler.fetch(new Request(request,{integrity:"no-cors"!==request.mode?integrityInRequest||integrityInManifest:void 0})),integrityInManifest&&noIntegrityConflict&&"no-cors"!==request.mode){this._useDefaultCacheabilityPluginIfNeeded();await handler.cachePut(request,response.clone());0}}return response}async _handleInstall(request,handler){this._useDefaultCacheabilityPluginIfNeeded();const response=await handler.fetch(request);if(!await handler.cachePut(request,response.clone()))throw new WorkboxError_WorkboxError("bad-precaching-response",{url:request.url,status:response.status});return response}_useDefaultCacheabilityPluginIfNeeded(){let defaultPluginIndex=null,cacheWillUpdatePluginCount=0;for(const[index,plugin]of this.plugins.entries())plugin!==PrecacheStrategy.copyRedirectedCacheableResponsesPlugin&&(plugin===PrecacheStrategy.defaultPrecacheCacheabilityPlugin&&(defaultPluginIndex=index),plugin.cacheWillUpdate&&cacheWillUpdatePluginCount++);0===cacheWillUpdatePluginCount?this.plugins.push(PrecacheStrategy.defaultPrecacheCacheabilityPlugin):cacheWillUpdatePluginCount>1&&null!==defaultPluginIndex&&this.plugins.splice(defaultPluginIndex,1)}}PrecacheStrategy.defaultPrecacheCacheabilityPlugin={async cacheWillUpdate({response:response}){return!response||response.status>=400?null:response}},PrecacheStrategy.copyRedirectedCacheableResponsesPlugin={async cacheWillUpdate({response:response}){return response.redirected?await copyResponse(response):response}};class PrecacheController{constructor({cacheName:cacheName,plugins:plugins=[],fallbackToNetwork:fallbackToNetwork=!0}={}){this._urlsToCacheKeys=new Map,this._urlsToCacheModes=new Map,this._cacheKeysToIntegrities=new Map,this._strategy=new PrecacheStrategy({cacheName:cacheNames_cacheNames_getPrecacheName(cacheName),plugins:[...plugins,new PrecacheCacheKeyPlugin({precacheController:this})],fallbackToNetwork:fallbackToNetwork}),this.install=this.install.bind(this),this.activate=this.activate.bind(this)}get strategy(){return this._strategy}precache(entries){this.addToCacheList(entries),this._installAndActiveListenersAdded||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this._installAndActiveListenersAdded=!0)}addToCacheList(entries){const urlsToWarnAbout=[];for(const entry of entries){"string"==typeof entry?urlsToWarnAbout.push(entry):entry&&void 0===entry.revision&&urlsToWarnAbout.push(entry.url);const{cacheKey:cacheKey,url:url}=createCacheKey(entry),cacheMode="string"!=typeof entry&&entry.revision?"reload":"default";if(this._urlsToCacheKeys.has(url)&&this._urlsToCacheKeys.get(url)!==cacheKey)throw new WorkboxError_WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(url),secondEntry:cacheKey});if("string"!=typeof entry&&entry.integrity){if(this._cacheKeysToIntegrities.has(cacheKey)&&this._cacheKeysToIntegrities.get(cacheKey)!==entry.integrity)throw new WorkboxError_WorkboxError("add-to-cache-list-conflicting-integrities",{url:url});this._cacheKeysToIntegrities.set(cacheKey,entry.integrity)}if(this._urlsToCacheKeys.set(url,cacheKey),this._urlsToCacheModes.set(url,cacheMode),urlsToWarnAbout.length>0){const warningMessage=`Workbox is precaching URLs without revision info: ${urlsToWarnAbout.join(", ")}\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(warningMessage)}}}install(event){return waitUntil(event,(async()=>{const installReportPlugin=new PrecacheInstallReportPlugin;this.strategy.plugins.push(installReportPlugin);for(const[url,cacheKey]of this._urlsToCacheKeys){const integrity=this._cacheKeysToIntegrities.get(cacheKey),cacheMode=this._urlsToCacheModes.get(url),request=new Request(url,{integrity:integrity,cache:cacheMode,credentials:"same-origin"});await Promise.all(this.strategy.handleAll({params:{cacheKey:cacheKey},request:request,event:event}))}const{updatedURLs:updatedURLs,notUpdatedURLs:notUpdatedURLs}=installReportPlugin;return{updatedURLs:updatedURLs,notUpdatedURLs:notUpdatedURLs}}))}activate(event){return waitUntil(event,(async()=>{const cache=await self.caches.open(this.strategy.cacheName),currentlyCachedRequests=await cache.keys(),expectedCacheKeys=new Set(this._urlsToCacheKeys.values()),deletedURLs=[];for(const request of currentlyCachedRequests)expectedCacheKeys.has(request.url)||(await cache.delete(request),deletedURLs.push(request.url));return{deletedURLs:deletedURLs}}))}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(url){const urlObject=new URL(url,location.href);return this._urlsToCacheKeys.get(urlObject.href)}getIntegrityForCacheKey(cacheKey){return this._cacheKeysToIntegrities.get(cacheKey)}async matchPrecache(request){const url=request instanceof Request?request.url:request,cacheKey=this.getCacheKeyForURL(url);if(cacheKey){return(await self.caches.open(this.strategy.cacheName)).match(cacheKey)}}createHandlerBoundToURL(url){const cacheKey=this.getCacheKeyForURL(url);if(!cacheKey)throw new WorkboxError_WorkboxError("non-precached-url",{url:url});return options=>(options.request=new Request(url),options.params=Object.assign({cacheKey:cacheKey},options.params),this.strategy.handle(options))}}let precacheController;const getOrCreatePrecacheController_getOrCreatePrecacheController=()=>(precacheController||(precacheController=new PrecacheController),precacheController);__webpack_require__("./node_modules/workbox-routing/_version.js");const normalizeHandler=handler=>handler&&"object"==typeof handler?handler:{handle:handler};class Route_Route{constructor(match,handler,method="GET"){this.handler=normalizeHandler(handler),this.match=match,this.method=method}setCatchHandler(handler){this.catchHandler=normalizeHandler(handler)}}class RegExpRoute extends Route_Route{constructor(regExp,handler,method){super((({url:url})=>{const result=regExp.exec(url.href);if(result&&(url.origin===location.origin||0===result.index))return result.slice(1)}),handler,method)}}class Router{constructor(){this._routes=new Map,this._defaultHandlerMap=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",(event=>{const{request:request}=event,responsePromise=this.handleRequest({request:request,event:event});responsePromise&&event.respondWith(responsePromise)}))}addCacheListener(){self.addEventListener("message",(event=>{if(event.data&&"CACHE_URLS"===event.data.type){const{payload:payload}=event.data;0;const requestPromises=Promise.all(payload.urlsToCache.map((entry=>{"string"==typeof entry&&(entry=[entry]);const request=new Request(...entry);return this.handleRequest({request:request,event:event})})));event.waitUntil(requestPromises),event.ports&&event.ports[0]&&requestPromises.then((()=>event.ports[0].postMessage(!0)))}}))}handleRequest({request:request,event:event}){const url=new URL(request.url,location.href);if(!url.protocol.startsWith("http"))return void 0;const sameOrigin=url.origin===location.origin,{params:params,route:route}=this.findMatchingRoute({event:event,request:request,sameOrigin:sameOrigin,url:url});let handler=route&&route.handler;const method=request.method;if(!handler&&this._defaultHandlerMap.has(method)&&(handler=this._defaultHandlerMap.get(method)),!handler)return void 0;let responsePromise;try{responsePromise=handler.handle({url:url,request:request,event:event,params:params})}catch(err){responsePromise=Promise.reject(err)}const catchHandler=route&&route.catchHandler;return responsePromise instanceof Promise&&(this._catchHandler||catchHandler)&&(responsePromise=responsePromise.catch((async err=>{if(catchHandler){0;try{return await catchHandler.handle({url:url,request:request,event:event,params:params})}catch(catchErr){catchErr instanceof Error&&(err=catchErr)}}if(this._catchHandler)return this._catchHandler.handle({url:url,request:request,event:event});throw err}))),responsePromise}findMatchingRoute({url:url,sameOrigin:sameOrigin,request:request,event:event}){const routes=this._routes.get(request.method)||[];for(const route of routes){let params;const matchResult=route.match({url:url,sameOrigin:sameOrigin,request:request,event:event});if(matchResult)return params=matchResult,(Array.isArray(params)&&0===params.length||matchResult.constructor===Object&&0===Object.keys(matchResult).length||"boolean"==typeof matchResult)&&(params=void 0),{route:route,params:params}}return{}}setDefaultHandler(handler,method="GET"){this._defaultHandlerMap.set(method,normalizeHandler(handler))}setCatchHandler(handler){this._catchHandler=normalizeHandler(handler)}registerRoute(route){this._routes.has(route.method)||this._routes.set(route.method,[]),this._routes.get(route.method).push(route)}unregisterRoute(route){if(!this._routes.has(route.method))throw new WorkboxError_WorkboxError("unregister-route-but-not-found-with-method",{method:route.method});const routeIndex=this._routes.get(route.method).indexOf(route);if(!(routeIndex>-1))throw new WorkboxError_WorkboxError("unregister-route-route-not-registered");this._routes.get(route.method).splice(routeIndex,1)}}let defaultRouter;const getOrCreateDefaultRouter_getOrCreateDefaultRouter=()=>(defaultRouter||(defaultRouter=new Router,defaultRouter.addFetchListener(),defaultRouter.addCacheListener()),defaultRouter);function registerRoute(capture,handler,method){let route;if("string"==typeof capture){const captureUrl=new URL(capture,location.href);0;route=new Route_Route((({url:url})=>url.href===captureUrl.href),handler,method)}else if(capture instanceof RegExp)route=new RegExpRoute(capture,handler,method);else if("function"==typeof capture)route=new Route_Route(capture,handler,method);else{if(!(capture instanceof Route_Route))throw new WorkboxError_WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});route=capture}return getOrCreateDefaultRouter_getOrCreateDefaultRouter().registerRoute(route),route}class PrecacheRoute extends Route_Route{constructor(precacheController,options){super((({request:request})=>{const urlsToCacheKeys=precacheController.getURLsToCacheKeys();for(const possibleURL of function*generateURLVariations(url,{ignoreURLParametersMatching:ignoreURLParametersMatching=[/^utm_/,/^fbclid$/],directoryIndex:directoryIndex="index.html",cleanURLs:cleanURLs=!0,urlManipulation:urlManipulation}={}){const urlObject=new URL(url,location.href);urlObject.hash="",yield urlObject.href;const urlWithoutIgnoredParams=function removeIgnoredSearchParams(urlObject,ignoreURLParametersMatching=[]){for(const paramName of[...urlObject.searchParams.keys()])ignoreURLParametersMatching.some((regExp=>regExp.test(paramName)))&&urlObject.searchParams.delete(paramName);return urlObject}(urlObject,ignoreURLParametersMatching);if(yield urlWithoutIgnoredParams.href,directoryIndex&&urlWithoutIgnoredParams.pathname.endsWith("/")){const directoryURL=new URL(urlWithoutIgnoredParams.href);directoryURL.pathname+=directoryIndex,yield directoryURL.href}if(cleanURLs){const cleanURL=new URL(urlWithoutIgnoredParams.href);cleanURL.pathname+=".html",yield cleanURL.href}if(urlManipulation){const additionalURLs=urlManipulation({url:urlObject});for(const urlToAttempt of additionalURLs)yield urlToAttempt.href}}(request.url,options)){const cacheKey=urlsToCacheKeys.get(possibleURL);if(cacheKey){return{cacheKey:cacheKey,integrity:precacheController.getIntegrityForCacheKey(cacheKey)}}}}),precacheController.strategy)}}const cacheOkAndOpaquePlugin_cacheOkAndOpaquePlugin={cacheWillUpdate:async({response:response})=>200===response.status||0===response.status?response:null};function _arrayLikeToArray(arr,len){(null==len||len>arr.length)&&(len=arr.length);for(var i=0,arr2=new Array(len);i<len;i++)arr2[i]=arr[i];return arr2}function _unsupportedIterableToArray(o,minLen){if(o){if("string"==typeof o)return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);return"Object"===n&&o.constructor&&(n=o.constructor.name),"Map"===n||"Set"===n?Array.from(o):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(o,minLen):void 0}}function _toConsumableArray(arr){return function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr)}(arr)||function _iterableToArray(iter){if("undefined"!=typeof Symbol&&null!=iter[Symbol.iterator]||null!=iter["@@iterator"])return Array.from(iter)}(arr)||_unsupportedIterableToArray(arr)||function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function _createForOfIteratorHelper(o,allowArrayLike){var it="undefined"!=typeof Symbol&&o[Symbol.iterator]||o["@@iterator"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&"number"==typeof o.length){it&&(o=it);var i=0,F=function F(){};return{s:F,n:function n(){return i>=o.length?{done:!0}:{done:!1,value:o[i++]}},e:function e(_e){throw _e},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var err,normalCompletion=!0,didErr=!1;return{s:function s(){it=it.call(o)},n:function n(){var step=it.next();return normalCompletion=step.done,step},e:function e(_e2){didErr=!0,err=_e2},f:function f(){try{normalCompletion||null==it.return||it.return()}finally{if(didErr)throw err}}}}var log=function(){},getBases=function(){var _ref=_asyncToGenerator(_regeneratorRuntime().mark((function _callee(){var cache,bases,baseCollection,_iterator,_step,base,cachedData;return _regeneratorRuntime().wrap((function _callee$(_context){for(;;)switch(_context.prev=_context.next){case 0:return _context.next=2,caches.open("bases");case 2:return cache=_context.sent,_context.next=5,cache.matchAll("/local-api/bases/",{ignoreSearch:!0});case 5:bases=_context.sent,baseCollection=[],_iterator=_createForOfIteratorHelper(bases),_context.prev=8,_iterator.s();case 10:if((_step=_iterator.n()).done){_context.next=18;break}return base=_step.value,_context.next=14,base.json();case 14:cachedData=_context.sent,baseCollection.push.apply(baseCollection,_toConsumableArray(cachedData));case 16:_context.next=10;break;case 18:_context.next=23;break;case 20:_context.prev=20,_context.t0=_context.catch(8),_iterator.e(_context.t0);case 23:return _context.prev=23,_iterator.f(),_context.finish(23);case 26:return log("".concat(baseCollection.length," bases found")),_context.abrupt("return",new Response(JSON.stringify(baseCollection)));case 28:case"end":return _context.stop()}}),_callee,null,[[8,20,23,26]])})));return function getBases(){return _ref.apply(this,arguments)}}(),postBase=function(){var _ref3=_asyncToGenerator(_regeneratorRuntime().mark((function _callee2(_ref2){var _data$name,request,data,cache,baseEntries,collectIds,_iterator2,_step2,basesData,id,dataObject;return _regeneratorRuntime().wrap((function _callee2$(_context2){for(;;)switch(_context2.prev=_context2.next){case 0:return request=_ref2.request,_context2.next=3,request.json();case 3:return data=_context2.sent,_context2.next=6,caches.open("bases");case 6:return cache=_context2.sent,_context2.next=9,cache.matchAll("/local-api/bases/",{ignoreSearch:!0});case 9:baseEntries=_context2.sent,collectIds=[],_iterator2=_createForOfIteratorHelper(baseEntries),_context2.prev=12,_iterator2.s();case 14:if((_step2=_iterator2.n()).done){_context2.next=22;break}return basesData=_step2.value,_context2.next=18,basesData.json();case 18:_context2.sent.forEach((function(d){return collectIds.push(d.id)}));case 20:_context2.next=14;break;case 22:_context2.next=27;break;case 24:_context2.prev=24,_context2.t0=_context2.catch(12),_iterator2.e(_context2.t0);case 27:return _context2.prev=27,_iterator2.f(),_context2.finish(27);case 30:for(id=1;collectIds.includes("u".concat(id));)id++;return dataObject={id:"u".concat(id),name:null!==(_data$name=data.name)&&void 0!==_data$name?_data$name:"New Village",layout:data.layout,builtIn:!1,version:1},_context2.next=35,cache.put("/local-api/bases/?id=u".concat(id),new Response(JSON.stringify([dataObject])));case 35:return _context2.abrupt("return",new Response(JSON.stringify(dataObject),{status:201}));case 36:case"end":return _context2.stop()}}),_callee2,null,[[12,24,27,30]])})));return function postBase(_x){return _ref3.apply(this,arguments)}}(),putBase=function(){var _ref5=_asyncToGenerator(_regeneratorRuntime().mark((function _callee3(_ref4){var url,request,data,id,cache,base,dataObject,previousData;return _regeneratorRuntime().wrap((function _callee3$(_context3){for(;;)switch(_context3.prev=_context3.next){case 0:return url=_ref4.url,request=_ref4.request,_context3.next=3,request.json();case 3:return data=_context3.sent,id=url.pathname.split("/").slice(-1)[0],_context3.next=7,caches.open("bases");case 7:return cache=_context3.sent,_context3.next=10,cache.match("/local-api/bases/?id=".concat(id));case 10:if(base=_context3.sent,dataObject={id:id,builtIn:!1,version:1},!base){_context3.next=17;break}return _context3.next=15,base.json();case 15:previousData=_context3.sent,Object.assign(dataObject,previousData);case 17:return Object.assign(dataObject,data),_context3.next=20,cache.put("/local-api/bases/?id=".concat(id),new Response(JSON.stringify([dataObject])));case 20:return log("base ".concat(id," updated")),_context3.abrupt("return",new Response(JSON.stringify(dataObject)));case 22:case"end":return _context3.stop()}}),_callee3)})));return function putBase(_x2){return _ref5.apply(this,arguments)}}(),deleteBase=function(){var _ref7=_asyncToGenerator(_regeneratorRuntime().mark((function _callee4(_ref6){var url,id,cache;return _regeneratorRuntime().wrap((function _callee4$(_context4){for(;;)switch(_context4.prev=_context4.next){case 0:return url=_ref6.url,id=url.pathname.split("/").slice(-1)[0],_context4.next=4,caches.open("bases");case 4:return cache=_context4.sent,_context4.next=7,cache.delete("/local-api/bases/?id=".concat(id));case 7:return log("base ".concat(id," deleted")),_context4.abrupt("return",new Response(JSON.stringify({status:"ok",id:id,message:"base deleted"})));case 9:case"end":return _context4.stop()}}),_callee4)})));return function deleteBase(_x3){return _ref7.apply(this,arguments)}}(),factoryBases=[{name:"Training level 1",layout:"eNotjdENwjAQQ32J7-oW2qSVUokFQGIGxmD_VeCQ-LOf5Gd98K6mwEvROO8FZ2d1dcakRuJk5u1Hs9aZGK5J14KxOJ6ulUbctkKl5N7oR8F-KbBORk65eKenKeTCsRKPRlHVMNJmCe3_Q30BDU8F4Q"}];!function clientsClaim(){self.addEventListener("activate",(()=>self.clients.claim()))}(),function precacheAndRoute(entries,options){!function precache(entries){getOrCreatePrecacheController_getOrCreatePrecacheController().precache(entries)}(entries),function addRoute(options){const precacheController=getOrCreatePrecacheController_getOrCreatePrecacheController();registerRoute(new PrecacheRoute(precacheController,options))}(options)}([{'revision':null,'url':'153.7fb4902f.iframe.bundle.js'},{'revision':null,'url':'341.45878a60.iframe.bundle.js'},{'revision':null,'url':'506.8746469e.iframe.bundle.js'},{'revision':null,'url':'51.76b2f604.iframe.bundle.js'},{'revision':null,'url':'644.4369bf8b.iframe.bundle.js'},{'revision':null,'url':'729.68885976.iframe.bundle.js'},{'revision':null,'url':'870.7db5faa6.iframe.bundle.js'},{'revision':null,'url':'925.d1de5be4.iframe.bundle.js'},{'revision':null,'url':'983.1a434294.iframe.bundle.js'},{'revision':'4ceba8138f963f1d47ffc2895619f6bc','url':'iframe.html'},{'revision':null,'url':'main.27161ab0.iframe.bundle.js'},{'revision':null,'url':'runtime~main.eae30c2c.iframe.bundle.js'},{'revision':null,'url':'static/css/main.ea3a8eb2.css'},{'revision':null,'url':'static/css/ui-components-atoms-Button-stories.2ec534ed.chunk.css'},{'revision':null,'url':'static/css/ui-components-atoms-CloudCurtain-stories.4151c530.chunk.css'},{'revision':null,'url':'static/css/ui-components-atoms-Destruction-stories.c6f7bf51.chunk.css'},{'revision':null,'url':'static/css/ui-components-atoms-Dialog-stories.121813e4.chunk.css'},{'revision':null,'url':'static/css/ui-components-atoms-Text-stories.a4aed84d.chunk.css'},{'revision':null,'url':'static/css/ui-components-atoms-Timer-stories.8d67a213.chunk.css'},{'revision':null,'url':'static/css/ui-components-atoms-Toolbar-stories.9ff9a3a5.chunk.css'},{'revision':null,'url':'static/css/ui-components-composition-ArmyTray-ArmyTray-stories.f067c25e.chunk.css'},{'revision':null,'url':'static/css/ui-components-composition-ArmyTray-Group-stories.8e040193.chunk.css'},{'revision':null,'url':'static/css/ui-components-composition-ArmyTray-UnitButton-stories.8e040193.chunk.css'},{'revision':null,'url':'static/css/ui-components-composition-Village-Building-stories.8e99bbd0.chunk.css'},{'revision':null,'url':'static/css/ui-components-composition-Village-Grid-stories.9127c8d5.chunk.css'},{'revision':null,'url':'static/css/ui-components-composition-Village-PlacementOutline-stories.8ef569ac.chunk.css'},{'revision':null,'url':'ui-components-atoms-Button-stories.664af3ce.iframe.bundle.js'},{'revision':null,'url':'ui-components-atoms-CloudCurtain-stories.a94e0407.iframe.bundle.js'},{'revision':null,'url':'ui-components-atoms-Destruction-stories.e196804e.iframe.bundle.js'},{'revision':null,'url':'ui-components-atoms-Dialog-stories.61e99ccd.iframe.bundle.js'},{'revision':null,'url':'ui-components-atoms-Text-stories.4b4229e8.iframe.bundle.js'},{'revision':null,'url':'ui-components-atoms-Timer-stories.d22166de.iframe.bundle.js'},{'revision':null,'url':'ui-components-atoms-Toolbar-stories.f9b53bb3.iframe.bundle.js'},{'revision':null,'url':'ui-components-composition-ArmyTray-ArmyTray-stories.29bf5b6c.iframe.bundle.js'},{'revision':null,'url':'ui-components-composition-ArmyTray-Group-stories.f53634eb.iframe.bundle.js'},{'revision':null,'url':'ui-components-composition-ArmyTray-UnitButton-stories.13b16661.iframe.bundle.js'},{'revision':null,'url':'ui-components-composition-Village-Building-stories.ac41d9fb.iframe.bundle.js'},{'revision':null,'url':'ui-components-composition-Village-Grid-stories.7a055003.iframe.bundle.js'},{'revision':null,'url':'ui-components-composition-Village-PlacementOutline-stories.9e3285e9.iframe.bundle.js'}]),registerRoute((function(_ref){return _ref.url.pathname.startsWith("/clash-bandicoot/storybook/")}),new class NetworkOnly extends Strategy_Strategy{constructor(options={}){super(options),this._networkTimeoutSeconds=options.networkTimeoutSeconds||0}async _handle(request,handler){let error,response;try{const promises=[handler.fetch(request)];if(this._networkTimeoutSeconds){const timeoutPromise=timeout_timeout(1e3*this._networkTimeoutSeconds);promises.push(timeoutPromise)}if(response=await Promise.race(promises),!response)throw new Error(`Timed out the network response after ${this._networkTimeoutSeconds} seconds.`)}catch(err){err instanceof Error&&(error=err)}if(!response)throw new WorkboxError_WorkboxError("no-response",{url:request.url,error:error});return response}});var fileExtensionRegexp=new RegExp("/[^/?]+\\.[^/]+$");registerRoute((function(_ref2){var request=_ref2.request,url=_ref2.url;return"navigate"===request.mode&&(!url.pathname.startsWith("/_")&&!url.pathname.match(fileExtensionRegexp))}),function createHandlerBoundToURL(url){return getOrCreatePrecacheController_getOrCreatePrecacheController().createHandlerBoundToURL(url)}("./index.html")),registerRoute((function(_ref3){var url=_ref3.url;return url.origin===self.location.origin&&url.pathname.endsWith(".png")}),new class StaleWhileRevalidate extends Strategy_Strategy{constructor(options={}){super(options),this.plugins.some((p=>"cacheWillUpdate"in p))||this.plugins.unshift(cacheOkAndOpaquePlugin_cacheOkAndOpaquePlugin)}async _handle(request,handler){const fetchAndCachePromise=handler.fetchAndCachePut(request).catch((()=>{}));handler.waitUntil(fetchAndCachePromise);let error,response=await handler.cacheMatch(request);if(response)0;else{0;try{response=await fetchAndCachePromise}catch(err){err instanceof Error&&(error=err)}}if(!response)throw new WorkboxError_WorkboxError("no-response",{url:request.url,error:error});return response}}({cacheName:"images",plugins:[new class ExpirationPlugin{constructor(config={}){this.cachedResponseWillBeUsed=async({event:event,request:request,cacheName:cacheName,cachedResponse:cachedResponse})=>{if(!cachedResponse)return null;const isFresh=this._isResponseDateFresh(cachedResponse),cacheExpiration=this._getCacheExpiration(cacheName);dontWaitFor(cacheExpiration.expireEntries());const updateTimestampDone=cacheExpiration.updateTimestamp(request.url);if(event)try{event.waitUntil(updateTimestampDone)}catch(error){0}return isFresh?cachedResponse:null},this.cacheDidUpdate=async({cacheName:cacheName,request:request})=>{const cacheExpiration=this._getCacheExpiration(cacheName);await cacheExpiration.updateTimestamp(request.url),await cacheExpiration.expireEntries()},this._config=config,this._maxAgeSeconds=config.maxAgeSeconds,this._cacheExpirations=new Map,config.purgeOnQuotaError&&function registerQuotaErrorCallback(callback){quotaErrorCallbacks.add(callback)}((()=>this.deleteCacheAndMetadata()))}_getCacheExpiration(cacheName){if(cacheName===cacheNames_cacheNames_getRuntimeName())throw new WorkboxError_WorkboxError("expire-custom-caches-only");let cacheExpiration=this._cacheExpirations.get(cacheName);return cacheExpiration||(cacheExpiration=new CacheExpiration(cacheName,this._config),this._cacheExpirations.set(cacheName,cacheExpiration)),cacheExpiration}_isResponseDateFresh(cachedResponse){if(!this._maxAgeSeconds)return!0;const dateHeaderTimestamp=this._getDateHeaderTimestamp(cachedResponse);if(null===dateHeaderTimestamp)return!0;return dateHeaderTimestamp>=Date.now()-1e3*this._maxAgeSeconds}_getDateHeaderTimestamp(cachedResponse){if(!cachedResponse.headers.has("date"))return null;const dateHeader=cachedResponse.headers.get("date"),headerTime=new Date(dateHeader).getTime();return isNaN(headerTime)?null:headerTime}async deleteCacheAndMetadata(){for(const[cacheName,cacheExpiration]of this._cacheExpirations)await self.caches.delete(cacheName),await cacheExpiration.delete();this._cacheExpirations=new Map}}({maxEntries:50})]})),registerRoute((function(_ref4){return _ref4.url.pathname.endsWith("/local-api/bases")}),getBases),registerRoute((function(_ref5){return _ref5.url.pathname.endsWith("/local-api/bases")}),postBase,"POST"),registerRoute((function(_ref6){var url=_ref6.url;return/local-api\/bases\/u\d+$/.test(url.pathname)}),putBase,"PUT"),registerRoute((function(_ref7){var url=_ref7.url;return/local-api\/bases\/u\d+$/.test(url.pathname)}),deleteBase,"DELETE"),self.addEventListener("install",(function(event){event.waitUntil(caches.open("bases").then(function(){var _ref8=_asyncToGenerator(_regeneratorRuntime().mark((function _callee(cache){return _regeneratorRuntime().wrap((function _callee$(_context){for(;;)switch(_context.prev=_context.next){case 0:return log("placing ".concat(factoryBases.length," bases in the cache")),_context.abrupt("return",cache.put("/local-api/bases/?id=builtin",new Response(JSON.stringify(factoryBases.map((function(record,index){return _objectSpread2(_objectSpread2({},record),{},{id:"bi".concat(index),builtIn:!0,version:1})}))))));case 2:case"end":return _context.stop()}}),_callee)})));return function(_x){return _ref8.apply(this,arguments)}}()))})),self.addEventListener("message",(function(event){event.data&&"SKIP_WAITING"===event.data.type&&self.skipWaiting()}))}()}();